[General]
%23preset_description=Cấu hình mẫu mặc định này gồm nhiều subtask
CLEAN_ROOT_FOLDER=true
FILENAME=A
GENERATE_OUTPUT=true
INPUT_CODE="vector <long long> fibo = {1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049, 12586269025, 20365011074, 32951280099, 53316291173, 86267571272, 139583862445, 225851433717, 365435296162, 591286729879, 956722026041, 1548008755920, 2504730781961, 4052739537881, 6557470319842, 10610209857723, 17167680177565, 27777890035288, 44945570212853, 7272346024814168};\nvector<long long> ok_nums, notok_nums;\n\nbool nt(const long long &n)\n{\n    if (n < 2) return false;\n    if (n != 4 && n < 6) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (long long i = 5; i * i <= n; i += 6)\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    return true;\n}\nconst int maxn = 1e6 + 5;\nbool f[maxn + 1];\nvoid sieve(void)\n{\n    memset(f, 0, sizeof(f));\n    for (int i = 2; i * i <= maxn; ++i)\n        if (f[i] == 0)\n        for (int j = i * i; j <= maxn; j += i)\n            f[j] = 1;\n}\n\nbool check_nt(const long long &n)\n{\n    if (n < 2) return false;\n    if (n < maxn) return (f[n] == 0);\n    else return (nt(n));\n}\n\nbool pick(long long n)\n{\n    for (long long num : fibo)\n    {\n        if (check_nt(n - num))\n            return true;\n        if (num > n)\n            break;\n    }\n    return false;\n}\n\nvoid buildNums() {\n    sieve();\n    for (int i = 1; i <= 1000000; i++) {\n        if (pick(i)) ok_nums.push_back(i);\n        else notok_nums.push_back(i);\n    }\n}\n\nvoid normalTest(ofstream& inp, int n) {\n    for (int i = 1; i <= n; i++) {\n        inp << randNum(1, 1e6) << ' ';\n    }\n}\n\nvoid funcInput(ofstream& inp) {\n    int limit1 = SUBTASK_LIMITS[0];\n    int limit2 = SUBTASK_LIMITS[1];\n    int n = randNum(limit1, limit2);\n    normalTest(inp, n);\n    inp << n << '\\n';\n}"
OUTPUT_CODE="#include <bits/stdc++.h>\n#define boostcode ios_base::sync_with_stdio(0); cin.tie(0);\n#define openf freopen(\"BAI2.INP\", \"r\", stdin); freopen(\"BAI2.OUT\", \"w\", stdout);\n\nusing namespace std;\ntypedef long long ll;\n\n// 1 <= n <= 200\n// 1 <= m[i] <= 10^6\n// 1 <= t[i] <= 10^4\nint n;\nint b[10002];\nint pos[10002];\nll res;\nbool d[202];\nqueue<int> out; // Lưu những công việc ưu tiên làm trước\n\nint main() {\n    boostcode;\n    openf;\n\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        int t, m;\n        cin >> t >> m;\n        if (m > b[t]) {\n            b[t] = m;\n            pos[t] = i;\n        }\n    }\n    for (int i = 1; i <= 10000; i++) {\n        res += b[i];\n        d[pos[i]] = true;\n        if (pos[i]) out.push(pos[i]);\n        //cout << i << ' ' << b[i] << ' ' << pos[i] << '\\n';\n    }\n    while (out.size()) {\n        cout << out.front() << '\\n';\n        out.pop();\n    }\n    for (int i = 1; i <= n; i++) {\n        if (!d[i]) cout << i << '\\n';\n    }\n    cout << res;\n\n    return 0;\n}"
OVERWRITE_OLD_TESTS=true
PREVENT_IDENTICAL_TESTS=false
SEPERATE_EACH_TEST=false
SHOW_COMPARE_ON_CMD=false
STRESS_TEST=false
STRESS_TEST_FORCE_STOP=false
STRESS_TEST_KEEP_WA_TEST_ONLY=false
STRESS_TEST_MOVE_WA_OUTPUT_TO_DIRECTORY=false
STRESS_TEST_SOLUTIONS=@Invalid()
STRESS_TEST_WRITE_REPORT=false
subtasks=@Variant(\0\0\0\x7f\0\0\0\bSubtask\0\0\0\0\x12\0S\0u\0\x62\0t\0\x61\0s\0k\0 \0\x31\0\0\0\x1\0\0\0\n\0\0\0\x2\0\0\0\x16\0G\0i\0\xe1\0 \0t\0r\x1e\xcb\0 \0m\0i\0n\0\0\0\x2\0\x31\0\0\0\x16\0G\0i\0\xe1\0 \0t\0r\x1e\xcb\0 \0m\0\x61\0x\0\0\0\b\0\x31\0\x30\0\x30\0\x30), @Variant(\0\0\0\x7f\0\0\0\bSubtask\0\0\0\0\x12\0S\0u\0\x62\0t\0\x61\0s\0k\0 \0\x32\0\0\0\v\0\0\0\x1e\0\0\0\x2\0\0\0\x16\0G\0i\0\xe1\0 \0t\0r\x1e\xcb\0 \0m\0i\0n\0\0\0\b\0\x31\0\x30\0\x30\0\x30\0\0\0\x16\0G\0i\0\xe1\0 \0t\0r\x1e\xcb\0 \0m\0\x61\0x\0\0\0\b\0\x31\0\x30\0\x30\0\x30), @Variant(\0\0\0\x7f\0\0\0\bSubtask\0\0\0\0\x12\0S\0u\0\x62\0t\0\x61\0s\0k\0 \0\x33\0\0\0\x1f\0\0\0(\0\0\0\x2\0\0\0\x16\0G\0i\0\xe1\0 \0t\0r\x1e\xcb\0 \0m\0i\0n\0\0\0\b\0\x31\0\x30\0\x30\0\x31\0\0\0\x16\0G\0i\0\xe1\0 \0t\0r\x1e\xcb\0 \0m\0\x61\0x\0\0\0\xe\0\x31\0\x30\0\x30\0\x30\0\x30\0\x30\0\x30), @Variant(\0\0\0\x7f\0\0\0\bSubtask\0\0\0\0\x12\0S\0u\0\x62\0t\0\x61\0s\0k\0 \0\x34\0\0\0)\0\0\0\x32\0\0\0\x2\0\0\0\x16\0G\0i\0\xe1\0 \0t\0r\x1e\xcb\0 \0m\0i\0n\0\0\0\xe\0\x31\0\x30\0\x30\0\x30\0\x30\0\x30\0\x30\0\0\0\x16\0G\0i\0\xe1\0 \0t\0r\x1e\xcb\0 \0m\0\x61\0x\0\0\0\xe\0\x31\0\x30\0\x30\0\x30\0\x30\0\x30\0\x30)
